#version 460

#include "incl/defs.glsl"
#include "incl/tone_mapping.glsl"

#define GROUP_SIZE 1024
#define THREADS_X  32
#define THREADS_Y  32

#define EPSILON 0.005

layout (std430, set = 0, binding = 0) 
#include "incl/computeSSBO.incl" 
ssbo;

layout (set = 0, binding = 1) 
#include "incl/computeUB.incl" 
ub;


layout (rgba32f, set = 0, binding = 2) uniform /*readonly*/ image2D inImage;
layout (rgba32f, set = 0, binding = 3) uniform writeonly image2D outImage;


const float WHITE_POINT = 10.0;

vec3 applyToneMapping(vec3 col) {
	vec3 outCol = col;
	switch (ub.toneMappingMode) {
        case 0: outCol = ReinhardExtended(col, WHITE_POINT); break;
        case 1: outCol = Reinhard(col); break;
        case 2: outCol = Uncharted2Filmic(col); break;
        case 3: outCol = ACESFilm(col); break;
        case 4: outCol = ACESFitted(col); break;
    }
	return outCol;
}

layout (local_size_x = THREADS_X, local_size_y = THREADS_Y) in;
void main() {
	uvec2 dim = imageSize(inImage).xy;
	// Ignore threads that map to areas beyond the bounds of our image
	if (gl_GlobalInvocationID.x < dim.x && gl_GlobalInvocationID.y < dim.y) {
		const float shadw = exp2(-1);
		const float highl = exp2(1);
		const float exposr = 1.0; // 0.7

		const float sigmaSq = 5 * 5;


        ivec2 coords = ivec2(gl_GlobalInvocationID.xy);
		vec3 inpColor = imageLoad(inImage, coords).rgb * exposr;

		vec3 highlights = clamp(applyToneMapping(inpColor * highl), 0.0, 1.0);
		vec3 midtones   = clamp(applyToneMapping(inpColor), 0.0, 1.0);
		vec3 shadows	= clamp(applyToneMapping(inpColor * shadw), 0.0, 1.0);

		vec3 lums = vec3(
			sqrt(dot(highlights, RGB_TO_LUM)),
			sqrt(dot(midtones  , RGB_TO_LUM)),
			sqrt(dot(shadows   , RGB_TO_LUM))
		);

		vec3 diff = lums - vec3(0.5);
        vec3 weights = vec3(exp(-0.5 * diff * diff * sigmaSq));
        weights /= dot(weights, vec3(1.0)) + 0.00001; // normalized weights

		vec3 outColor = highlights * weights.x + midtones * weights.y + shadows * weights.z;
		//vec3 outColor = vec3(dot(lums, weights));

        //imageStore(outImage, coords, vec4(outColor, 1.0));
		imageStore(inImage, coords, vec4(outColor, 1.0));
	}
}