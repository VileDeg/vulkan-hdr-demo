#version 460

#include "incl/defs.glsl"
#include "incl/compute_structs.glsl"

#define GROUP_SIZE 1024
#define THREADS_X  32
#define THREADS_Y  32

layout (set = 0, binding = 0) 
#include "incl/computeUB.incl" 
ub;

layout (rgba32f, set = 0, binding = 1) uniform readonly image2D inlogLumImage;

layout (rgba32f, set = 0, binding = 2) uniform writeonly image2D baseFreqImage;
layout (rgba32f, set = 0, binding = 3) uniform writeonly image2D detailImage;

#define _D ub.durand

layout (local_size_x = THREADS_X, local_size_y = THREADS_Y) in;
void main() {
	uvec2 dim = imageSize(inlogLumImage).xy;
	ivec2 coords = ivec2(gl_GlobalInvocationID.xy);
	// Ignore threads that map to areas beyond the bounds of our image
	if (gl_GlobalInvocationID.x < dim.x && gl_GlobalInvocationID.y < dim.y) {

        vec3 c = imageLoad(inlogLumImage, coords).rgb;
		
		const int kSize = (_D.bilateralRadius-1)/2;

		vec3 outColor = vec3(0);
		float weight_sum = 0;

		for (int i = -kSize; i <= kSize; ++i) {
			for (int j = -kSize; j <= kSize; ++j) {
				vec3 cc = imageLoad(inlogLumImage, coords + ivec2(i, j)).rgb;
				float dist = (i*i + j*j) / (2 * _D.sigmaS * _D.sigmaS);
				float intense = pow(length(c-cc), 2) / (2 * _D.sigmaR * _D.sigmaR);

				float w = exp(-dist - intense);

				outColor += w * cc;
				weight_sum += w;
			}
		}

		outColor /= weight_sum;
		
		vec3 base = outColor;
		imageStore(baseFreqImage, coords, vec4(base, 1.0));

		float lum = dot(c, RGB_TO_LUM);

#if   DURAND_DETAIL_ABS == 0
		vec3 detail = lum - base;
#elif DURAND_DETAIL_ABS == 1
		vec3 detail = abs(lum - base);
#endif
		imageStore(detailImage, coords, vec4(detail, 1.0));
	}
}