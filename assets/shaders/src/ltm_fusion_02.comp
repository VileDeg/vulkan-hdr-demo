#version 460

#include "incl/defs.glsl"

#define GROUP_SIZE 1024
#define THREADS_X  32
#define THREADS_Y  32

layout (std430, set = 0, binding = 0) 
#include "incl/computeSSBO.incl" 
ssbo;

layout (set = 0, binding = 1) 
#include "incl/computeUB.incl" 
ub;

#include "incl/compPC.incl"
pc;

layout (rgba32f, set = 0, binding = 2) uniform readonly image2D inMips[MAX_VIEWPORT_MIPS];

layout (rgba32f, set = 0, binding = 3) uniform writeonly image2D outMips[MAX_VIEWPORT_MIPS];

layout (local_size_x = THREADS_X, local_size_y = THREADS_Y) in;
void main() {
	int i = pc.mipIndex;
	uvec2 dim = imageSize(inMips[i]).xy; // Mip level 0 corresponds to full-res images
	// Ignore threads that map to areas beyond the bounds of our image
	if (gl_GlobalInvocationID.x < dim.x && gl_GlobalInvocationID.y < dim.y) {
        ivec2 coords = ivec2(gl_GlobalInvocationID.xy);

		vec3 higher = imageLoad(inMips[i], coords).rgb;
		
		ivec2 coordsLower = coords >> 1;
		// Since our initial viewport image doesn't have dimensions which are power of 2, 
		// there will be missalignment between different mip levels
		// so we just use CLAMP_TO_BORDER approach when we sample outside of mip dimensions
		ivec2 dimLower = imageSize(inMips[i+1]).xy;
		coordsLower.x = min(coordsLower.x, dimLower.x-1);
		coordsLower.y = min(coordsLower.y, dimLower.y-1);

		vec3 lower = imageLoad(inMips[i+1], coordsLower).rgb;

		vec3 diff = higher - lower;
		imageStore(outMips[i], coords, vec4(diff, 1.0));

		if (i == ub.numOfViewportMips-2) {
			imageStore(outMips[i+1], coordsLower, vec4(lower, 1.0));
		}
	}	
}
