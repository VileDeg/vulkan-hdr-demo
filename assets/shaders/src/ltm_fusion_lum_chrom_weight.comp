#version 460

#include "incl/defs.glsl"
#include "incl/tone_mapping.glsl"
#include "incl/color_spaces.glsl"

#define GROUP_SIZE 1024
#define THREADS_X  32
#define THREADS_Y  32

layout (set = 0, binding = 0) 
#include "incl/computeUB.incl" 
ub;

layout (rgba32f, set = 0, binding = 1) uniform readonly image2D inImage;

layout (rgba32f, set = 0, binding = 2) uniform writeonly image2D chrominanceImage;

layout (rgba32f, set = 0, binding = 3) uniform writeonly image2D luminanceImage;
layout (rgba32f, set = 0, binding = 4) uniform writeonly image2D weightImage;

float saturation(vec3 col) {
	float sum0 = dot(col, vec3(1)) / 3;

	vec3 pw = col - sum0;
	pw *= pw;
	float sum1 = pw.x + pw.y + pw.z;

	float saturation = sqrt(sum1 / 3);
	return saturation;
}

float exposedness(vec3 col, float sigma) {
	float exposedness = exp(-pow(col.x - 0.5, 2) / (2 * sigma * sigma) );
	exposedness *= exp(-pow(col.y - 0.5, 2) / (2 * sigma * sigma) );
	exposedness *= exp(-pow(col.z - 0.5, 2) / (2 * sigma * sigma) );

	return exposedness;
}

layout (local_size_x = THREADS_X, local_size_y = THREADS_Y) in;
void main() {
	uvec2 dim = imageSize(inImage).xy;
	// Ignore threads that map to areas beyond the bounds of our image
	if (gl_GlobalInvocationID.x < dim.x && gl_GlobalInvocationID.y < dim.y) {
        ivec2 coords  = ivec2(gl_GlobalInvocationID.xy);
		vec3 inpColor = imageLoad(inImage, coords).rgb;

		vec3 highlightsColor = applyGlobalToneMapping(inpColor * exp2(ub.highlightsExposure), ub.toneMappingMode);
		vec3 midtonesColor	 = applyGlobalToneMapping(inpColor, ub.toneMappingMode);
		vec3 shadowsColor	 = applyGlobalToneMapping(inpColor * exp2(ub.shadowsExposure), ub.toneMappingMode);

		vec3 lums  = vec3(
			dot(highlightsColor, RGB_TO_LUM), 
			dot(midtonesColor, RGB_TO_LUM), 
			dot(shadowsColor, RGB_TO_LUM)
		);

		// Compute weights of three exposures based on closedness to gray (measured with Gaussian function)
		vec3 expos = vec3(
			exposedness(highlightsColor, ub.exposednessWeightSigma), 
			exposedness(midtonesColor  , ub.exposednessWeightSigma), 
			exposedness(shadowsColor   , ub.exposednessWeightSigma)
		);

#if FUSION_WEIGHT_MODE == 0
		vec3 satur = vec3(saturation(highlightsColor), saturation(midtonesColor), saturation(shadowsColor));
#else
		vec3 satur = vec3(1);
#endif
		vec3 weights = expos * satur;

		// Normalize weights
        weights /= dot(weights, vec3(1.0)) + 0.00001;

		imageStore(luminanceImage, coords, vec4(lums, 1.0));

		// Blend the colors to restore the right color in the last step that would correspond to blended luminances
		vec3 blendedColor = highlightsColor * weights.x + midtonesColor * weights.y + shadowsColor * weights.z;
		vec3 lab = rgb2lab(blendedColor);
        vec3 chrom = lab;

		imageStore(chrominanceImage, coords, vec4(chrom, 1.0));

		imageStore(weightImage, coords, vec4(weights, 1.0));
	}
}