#version 460

#include "incl/defs.glsl"
#include "incl/tone_mapping.glsl"

#define GROUP_SIZE 1024
#define THREADS_X  32
#define THREADS_Y  32

layout (set = 0, binding = 0) 
#include "incl/computeUB.incl" 
ub;

layout (rgba32f, set = 0, binding = 1) uniform readonly image2D inChrominanceImage;
//layout (rgba32f, set = 0, binding = 1) uniform readonly image2D inOriginalImage;
layout (rgba32f, set = 0, binding = 2) uniform readonly image2D inLaplacianSumImage;

layout (rgba32f, set = 0, binding = 3) uniform writeonly image2D finalImage;

const float WHITE_POINT = 10.0;

vec3 applyToneMapping(vec3 col) {
	vec3 outCol = col;
	switch (ub.toneMappingMode) {
        case 0: outCol = ReinhardExtended(col, WHITE_POINT); break;
        case 1: outCol = Reinhard(col); break;
        case 2: outCol = Uncharted2Filmic(col); break;
        case 3: outCol = ACESFilm(col); break;
        case 4: outCol = ACESFitted(col); break;
    }
	return outCol;
}


vec3 lab2xyz( vec3 c ) {
    float fy = ( c.x + 16.0 ) / 116.0;
    float fx = c.y / 500.0 + fy;
    float fz = fy - c.z / 200.0;
    return vec3(
         95.047 * (( fx > 0.206897 ) ? fx * fx * fx : ( fx - 16.0 / 116.0 ) / 7.787),
        100.000 * (( fy > 0.206897 ) ? fy * fy * fy : ( fy - 16.0 / 116.0 ) / 7.787),
        108.883 * (( fz > 0.206897 ) ? fz * fz * fz : ( fz - 16.0 / 116.0 ) / 7.787)
    );
}

vec3 xyz2rgb( vec3 c ) {
    vec3 v =  c / 100.0 * mat3( 
        3.2406, -1.5372, -0.4986,
        -0.9689, 1.8758, 0.0415,
        0.0557, -0.2040, 1.0570
    );
    vec3 r;
    r.x = ( v.r > 0.0031308 ) ? (( 1.055 * pow( v.r, ( 1.0 / 2.4 ))) - 0.055 ) : 12.92 * v.r;
    r.y = ( v.g > 0.0031308 ) ? (( 1.055 * pow( v.g, ( 1.0 / 2.4 ))) - 0.055 ) : 12.92 * v.g;
    r.z = ( v.b > 0.0031308 ) ? (( 1.055 * pow( v.b, ( 1.0 / 2.4 ))) - 0.055 ) : 12.92 * v.b;
    return r;
}

vec3 lab2rgb(vec3 c) {
    return xyz2rgb( lab2xyz( vec3(100.0 * c.x, 2.0 * 127.0 * (c.y - 0.5), 2.0 * 127.0 * (c.z - 0.5)) ) );
}

const float exposure = 1.0;

layout (local_size_x = THREADS_X, local_size_y = THREADS_Y) in;
void main() {
	uvec2 dim = imageSize(inLaplacianSumImage).xy; // Mip level 0 corresponds to full-res image
    ivec2 coords = ivec2(gl_GlobalInvocationID.xy);
	// Ignore threads that map to areas beyond the bounds of our image
	if (coords.x < dim.x && coords.y < dim.y) {
        

		vec3  chrom = imageLoad(inChrominanceImage, coords).rgb;
		float laplacianSum = imageLoad(inLaplacianSumImage, coords).r; // Since it's luminance we only need one channel
        
		//vec3 orig = max(applyToneMapping(imageLoad(inOriginalImage, coords).rgb * exposure), 0.0);
        //float luminance = dot(orig, RGB_TO_LUM) + 0.00001;

        //float finalMultiplier = max(luminance, 0.0) / luminance;
        // This is a hack to prevent super dark pixels getting boosted by a lot and showing compression artifacts.
        //float lerpToUnityThreshold = 0.007;
        //finalMultiplier = luminance > lerpToUnityThreshold ? finalMultiplier : 
        //    mix(1.0, finalMultiplier, (luminance / lerpToUnityThreshold) * (luminance / lerpToUnityThreshold));
            
        //vec3 final = max(applyToneMapping(imageLoad(inOriginalImage, coords).rgb * exposure * finalMultiplier), 0.0);

        //vec3 chrom = orig / luminance;
        vec3 final = lab2rgb(vec3(laplacianSum, chrom.y, chrom.z));
        //vec3 final = vec3(laplacianSum) * RGB_TO_LUM;

		imageStore(finalImage, coords, vec4(final, 1.0));
	}
}