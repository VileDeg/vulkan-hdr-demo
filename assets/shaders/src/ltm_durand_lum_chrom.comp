#version 460

#include "incl/defs.glsl"
#include "incl/compute_structs.glsl"
#include "incl/color_spaces.glsl"

#define GROUP_SIZE 1024
#define THREADS_X  32
#define THREADS_Y  32

layout (set = 0, binding = 0) 
#include "incl/computeUB.incl" 
ub;

layout (rgba32f, set = 0, binding = 1) uniform readonly image2D inImage;

layout (rgba32f, set = 0, binding = 2) uniform writeonly image2D logLumImage;
layout (rgba32f, set = 0, binding = 3) uniform writeonly image2D chrominanceImage;

layout (local_size_x = THREADS_X, local_size_y = THREADS_Y) in;
void main() {
	uvec2 dim = imageSize(inImage).xy;
	// Ignore threads that map to areas beyond the bounds of our image
	if (gl_GlobalInvocationID.x < dim.x && gl_GlobalInvocationID.y < dim.y) {
        ivec2 coords = ivec2(gl_GlobalInvocationID.xy);
		vec3 inpColor = imageLoad(inImage, coords).rgb;

		float lum = dot(inpColor, RGB_TO_LUM);

#if DURAND_CONVERT_LAB == 0 // <-- See defs.glsl
		vec3 chrom = inpColor / lum;
#else
		vec3 chrom = rgb2lab(inpColor);
#endif

#if DURAND_LOG_LUM == 1 // <-- See defs.glsl
		lum = lum * DURAND_LOG_LUM_RES + 1;
		lum = log2(lum);
#endif
		
		imageStore(logLumImage, coords, vec4(vec3(lum), 1.0));
		imageStore(chrominanceImage, coords, vec4(chrom, 1.0));
	}
}