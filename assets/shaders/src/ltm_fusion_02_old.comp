#version 460

#include "incl/defs.glsl"

#define GROUP_SIZE 1024
#define THREADS_X  32
#define THREADS_Y  32

layout (std430, set = 0, binding = 0) 
#include "incl/computeSSBO.incl" 
ssbo;

layout (set = 0, binding = 1) 
#include "incl/computeUB.incl" 
ub;

layout (rgba32f, set = 0, binding = 2) uniform readonly image2D inLuminanceMips[MAX_VIEWPORT_MIPS];

layout (rgba32f, set = 0, binding = 3) uniform writeonly image2D laplacianMips[MAX_VIEWPORT_MIPS];

const float sigmaSq = 5 * 5;

layout (local_size_x = THREADS_X, local_size_y = THREADS_Y) in;
void main() {
	uvec2 dim = imageSize(inLuminanceMips[0]).xy; // Mip level 0 corresponds to full-res images
	// Ignore threads that map to areas beyond the bounds of our image
	if (gl_GlobalInvocationID.x < dim.x && gl_GlobalInvocationID.y < dim.y) {
        ivec2 coords = ivec2(gl_GlobalInvocationID.xy);

		vec3 lum = imageLoad(inLuminanceMips[0], coords).rgb;
		imageStore(laplacianMips[0], coords, vec4(lum, 1.0));

		for (int i = 0; i < ub.numOfViewportMips-1; ++i) {
			//vec3 lum = imageLoad(inLuminanceMips[i], coords).rgb;
			vec3 lum[4] = { imageLoad(inLuminanceMips[i], coords).rgb, imageLoad(inLuminanceMips[i], coords).rgb,  imageLoad(inLuminanceMips[i], coords).rgb, imageLoad(inLuminanceMips[i], coords).rgb, };
			vec3 lumAvg = vec3(0);
			for (int l = 0; l < 4; ++l) {
				lumAvg += lum[l];
			}
			lumAvg /= 4;

			ivec2 coordsNext = coords >> 1;

			// Since our initial viewport image doesn't have dimensions which are power of 2, 
			// we will he missalignment between different mip levels
			// so we just use CLAMP_TO_BORDER approach when we sample outside of mip dimensions
			ivec2 dimNext = imageSize(inLuminanceMips[i+1]).xy;
			//coordsNext.x = min(coordsNext.x, dimNext.x-1);
			//coordsNext.y = min(coordsNext.y, dimNext.y-1);

			vec3 lumNext = imageLoad(inLuminanceMips[i+1], coordsNext).rgb;

			//vec3 laplacian = lum - lumNext;
			vec3 laplacian = lumAvg;
			imageStore(laplacianMips[i+1], coordsNext, vec4(laplacian, 1.0));

			coords = coordsNext;
		}
	}
}
