// Based on https://bruop.github.io/exposure/
#version 460

#include "incl/defs.glsl"
#include "incl/tone_mapping.glsl"

layout (std430, set = 0, binding = 0) 
#include "incl/luminanceSSBO.incl" 
ssbo;

layout (set = 0, binding = 1) 
#include "incl/luminanceUB.incl" 
ub;

#define THREADS_X 32
#define THREADS_Y 32



layout (rgba32f, set = 0, binding = 2) uniform image2D inOutHDRImage;

const float WHITE_POINT = 10.0;
const float GAMMA = 2.2;

layout (local_size_x = THREADS_X, local_size_y = THREADS_Y) in;
void main() {
    uvec2 dim = imageSize(inOutHDRImage).xy;
 
    // Ignore threads that map to areas beyond the bounds of our HDR image
    if (gl_GlobalInvocationID.x < dim.x && gl_GlobalInvocationID.y < dim.y) {
        vec3 hdrColor = imageLoad(inOutHDRImage, ivec2(gl_GlobalInvocationID.xy)).rgb;
        // Apply eye adaptation
        vec3 outColor = hdrColor;
        if (ub.enableAdaptation) {
            outColor = outColor / (9.6 * ssbo.averageLuminance + 0.0001);
            //outColor = outColor * ssbo.averageLuminance;
        }
        // Apply tone mapping
        if (ub.enableToneMapping) { // If enable tone mapping
            switch (ub.toneMappingMode) {
                case 0: outColor = ReinhardExtended(outColor, WHITE_POINT); break;
                case 1: outColor = Reinhard(outColor); break;
                case 2: outColor = Uncharted2Filmic(outColor); break;
                case 3: outColor = ACESFilm(outColor); break;
                case 4: outColor = ACESFitted(outColor); break;
            }
        }

        // Gamma correction
        switch (ub.gammaMode) {
            case 0: outColor = outColor; break;
            case 1: outColor = pow(outColor, vec3(GAMMA)); break;
            case 2: outColor = pow(outColor, vec3(1.0 / GAMMA)); break;
        }

        // Store final color
        imageStore(inOutHDRImage, ivec2(gl_GlobalInvocationID.xy), vec4(outColor, 1.0));
    }
}