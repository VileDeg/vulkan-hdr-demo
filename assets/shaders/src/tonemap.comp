// Based on https://bruop.github.io/exposure/

#version 460

#include "defs.glsl"
#include "tone_mapping.glsl"

#include "comp_buffer.glsl"

#define GROUP_SIZE 1024
#define THREADS_X 32
#define THREADS_Y 32

layout (rgba32f, set = 0, binding = 1) uniform image2D inOutHDRImage;

const float WHITE_POINT = 10.f;
const float GAMMA = 2.2f;

layout (local_size_x = THREADS_X, local_size_y = THREADS_Y) in;
void main() {
    uvec2 dim = imageSize(inOutHDRImage).xy;
 
    // Ignore threads that map to areas beyond the bounds of our HDR image
    if (gl_GlobalInvocationID.x < dim.x && gl_GlobalInvocationID.y < dim.y) {
        vec3 hdrColor = imageLoad(inOutHDRImage, ivec2(gl_GlobalInvocationID.xy)).xyz;
        // Apply eye adaptation
        vec3 outColor = hdrColor;
        if (ssbo.enableAdaptation == 1) {
            outColor = outColor / (9.6 * ssbo.averageLuminance);
        }
        // Apply tone mapping
        if (ssbo.enableToneMapping == 1) { // If enable tone mapping
            switch (ssbo.toneMappingMode) {
                case 0: outColor = ReinhardExtended(outColor, WHITE_POINT); break;
                case 1: outColor = Reinhard(outColor); break;
                case 2: outColor = Uncharted2Filmic(outColor); break;
                case 3: outColor = ACESFilm(outColor); break;
                case 4: outColor = ACESFitted(outColor); break;
            }
        }

        // Gamma correction
        switch (ssbo.gammaMode) {
            case 0: outColor = outColor; break;
            case 1: outColor = pow(outColor, vec3(GAMMA)); break;
            case 2: outColor = pow(outColor, vec3(1.f / GAMMA)); break;
        }

        // Store final color
        imageStore(inOutHDRImage, ivec2(gl_GlobalInvocationID.xy), vec4(outColor, 1.f));
    }
}