#version 460

#include "incl/defs.glsl"

#define GROUP_SIZE 1024
#define THREADS_X  32
#define THREADS_Y  32

layout (set = 0, binding = 0) 
#include "incl/computeUB.incl" 
ub;

#include "incl/compPC.incl"
pc;

layout (rgba32f, set = 0, binding = 1) uniform readonly image2D inFilteredImage[MAX_VIEWPORT_MIPS];

layout (rgba32f, set = 0, binding = 2) uniform writeonly image2D decimatedImage[MAX_VIEWPORT_MIPS]; // <- threads of this res

// 1D part of the pyramid filter, as defined in Merten's implementation:
// https://github.com/Mericam/exposure-fusion
#define MSIZE 5
const float[MSIZE] f = { .0625, .25, .375, .25, .0625 };

#define EDGE_MODE 1

ivec2 borderWrap(ivec2 coords, ivec2 dim) {
	if (coords.x > dim.x-1) {
		coords.x -= dim.x;
	}
	if (coords.y > dim.y-1) {
		coords.y -= dim.y;
	}
	if (coords.x < 0) {
		coords.x += dim.x-1;
	}
	if (coords.y < 0) {
		coords.y += dim.y-1;
	}
	return coords;
}


layout (local_size_x = THREADS_X, local_size_y = THREADS_Y) in;
void main() {
	int i = pc.mipIndex;
	ivec2 dim = imageSize(decimatedImage[i]).xy;
	ivec2 coords = ivec2(gl_GlobalInvocationID.xy);

	if (coords.x < dim.x && coords.y < dim.y) {
		//ivec2 coordsLower = borderClamp(coords >> 1, imageSize(decimatedImage[i+1]).xy);
/*		ivec2 coordsHigher = coords << 1;
		
		vec3 px = vec3(0);
		// Horizontal
		ivec2 dir = ivec2(1, 0);
		for (int j = -(MSIZE/2); j < (MSIZE/2+1); ++j) {
			ivec2 sampleFrom = coordsHigher + dir * j;
#if EDGE_MODE == 0
			sampleFrom = borderWrap(sampleFrom, dim);
#else
			sampleFrom = borderClamp(sampleFrom, dim);
#endif
			px += imageLoad(inFilteredImage[i-1], sampleFrom).rgb * f[j + MSIZE/2];
		}
		imageStore(decimatedImage[i], coords, vec4(px, 1.0));
		barrier();

		// Vertical
		dir = ivec2(0, 1);
		for (int j = -(MSIZE/2); j < (MSIZE/2+1); ++j) {
			ivec2 sampleFrom = coordsHigher + dir * j;
#if EDGE_MODE == 0
			sampleFrom = borderWrap(sampleFrom, dim);
#else
			sampleFrom = borderClamp(sampleFrom, dim);
#endif
			px += imageLoad(inFilteredImage[i-1], sampleFrom).rgb * f[j + MSIZE/2];
		}*/

		imageStore(decimatedImage[i], coords, vec4(imageLoad(inFilteredImage[i-1], coords << 1).rgb, 1.0));
	}
}
