// Based on https://bruop.github.io/exposure/
#version 460

#include "incl/defs.glsl"

#define GROUP_SIZE 256
#define THREADS_X 256
#define THREADS_Y 1

#define localIndex gl_LocalInvocationIndex

layout (std430, set = 0, binding = 0) 
#include "incl/luminanceSSBO.incl" 
ssbo;

layout (set = 0, binding = 1) 
#include "incl/luminanceUB.incl" 
ub;

// Shared
shared uint histogramShared[GROUP_SIZE];

layout (local_size_x = THREADS_X, local_size_y = THREADS_Y) in;
void main() {
  // Get the count from the histogram buffer
  uint countForThisBin = ssbo.histogram[localIndex];

  histogramShared[localIndex] = uint(countForThisBin * uint(localIndex * ub.weights.x));
  //histogramShared[localIndex] = uint(countForThisBin);

  barrier();

  // We only need to calculate this once, so only a single thread is needed.
  if (localIndex == 0) {
    uint sum = 0;
    uint total_pixels = 0;
    for (uint i = ub.lumLowerIndex; i < ub.lumUpperIndex+1; ++i) {
    //for (uint i = 0; i < MAX_LUMINANCE_BINS; ++i) {
        sum += histogramShared[i];
        total_pixels += ssbo.histogram[i];
    }
    //total_pixels -= histogramShared[0];

    // Here we take our weighted sum and divide it by the number of pixels
    // that had luminance greater than zero (since the index == 0, we can
    // use countForThisBin to find the number of black pixels)
    //float weightedLogAverage = (sum / max(float(ub.totalPixelNum), 1.0)) - 1.0; //  - float(countForThisBin)
    float weightedLogAverage = (sum / max(float(total_pixels), 1.0)) - 1.0;

    // Map from our histogram space to actual luminance
    float weightedAvgLum = exp2(((weightedLogAverage / 254.0) * ub.logLumRange) + ub.minLogLum);

    //float awaitedLuminance = ub.weights.z;
    //float howClose = weightedAvgLum - awaitedLuminance;
    //weightedAvgLum = weightedAvgLum * exp2(-howClose * ub.weights.w);

    // Set target luminance for display and comparison
    ssbo.targetAverageLuminance = weightedAvgLum;

    // The new stored value will be interpolated using the last frames value
    // to prevent sudden shifts in the exposure.
    float lumLastFrame = ssbo.averageLuminance;
    float adaptedLum = lumLastFrame + (weightedAvgLum - lumLastFrame) * ub.timeCoeff;

    ssbo.averageLuminance = adaptedLum;
    //ssbo.averageLuminance = 1 / (9.6 * adaptedLum + 0.0001);
  }
}
