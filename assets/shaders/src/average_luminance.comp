// Based on https://bruop.github.io/exposure/
#version 460

#include "incl/defs.glsl"

#define GROUP_SIZE 256
#define THREADS_X 256
#define THREADS_Y 1

#define localIndex gl_LocalInvocationIndex

layout (std430, set = 0, binding = 0) 
#include "incl/luminanceSSBO.incl" 
ssbo;

layout (set = 0, binding = 1) 
#include "incl/luminanceUB.incl" 
ub;

// Shared
shared uint histogramShared[GROUP_SIZE];

layout (local_size_x = THREADS_X, local_size_y = THREADS_Y) in;
void main() {
  // Get the count from the histogram buffer
  uint countForThisBin = ssbo.histogram[localIndex];

  histogramShared[localIndex] = uint(countForThisBin * uint(localIndex * ub.weights.x));

  barrier();

  // We only need to calculate this once, so only a single thread is needed.
  if (localIndex == 255) {
    uint sum = 0;
    for (uint i = ub.lumLowerIndex; i < ub.lumUpperIndex+1; ++i) {
        sum += histogramShared[i];
    }

    // Here we take our weighted sum and divide it by the number of pixels
    // that had luminance greater than zero (since the index == 0, we can
    // use countForThisBin to find the number of black pixels)
    float weightedLogAverage = (sum / max(float(ub.totalPixelNum), 1.0)) - 1.0; //  - float(countForThisBin)

    // Map from our histogram space to actual luminance
    float weightedAvgLum = exp2(((weightedLogAverage / 254.0) * ub.logLumRange) + ub.minLogLum);

    float awaitedLuminance = ub.weights.z;
    float howClose = weightedAvgLum - awaitedLuminance;
    weightedAvgLum = weightedAvgLum * exp2(howClose * ub.weights.w);
    // Set target luminance for display and comparison
    ssbo.targetAverageLuminance = weightedAvgLum;

    // The new stored value will be interpolated using the last frames value
    // to prevent sudden shifts in the exposure.
    float lumLastFrame = ssbo.averageLuminance;
    float adaptedLum = lumLastFrame + (weightedAvgLum - lumLastFrame) * ub.timeCoeff;

    ssbo.averageLuminance = adaptedLum;
  }
}